---
date: '2019-10-12'
slug: 'functional-lenses'
title: 'Functional Lenses'
---

The other day I was making changes to a part of Webflow's codebase that heavily depends on _lenses_. If you've never heard about them, have no fear. I had no idea what they were either. But after some research, I quickly realized just how useful they can be and why we use them at Webflow and why I might use them in my own projects going forward. Let me teach you what I've learned.

### What is a `lens`?

A lens is a composable pair of pure functions, a "getter" and a "setter", that focuses in on a particular part of a greater data structure (typically an object, but it can be other data structures as well). The lens is used to `view` and `set` that focused part and decouples how we do that from the structure of the data itself. This will make more sense soon.

The getter of a lens receives the whole data structure and returns just the part on which it is focused. The setter of a lens receives the whole data structure, the value we'd like to set at the part on which we are focused, and returns a brand new data structure with the updated data (this is an immutable update, to learn more about immutability, you can read my blog post on it [here](/just-enough-fp-immutability)).

If we were to make some functions that do this ourselves, they might look something like this:

```javascript
// Generic `view` and `set` functions that can be used on any lens
const view = (lens, store) => lens.view(store)
const set = (lens, value, store) => lens.set(value, store)

// A lens factory that is designed to specifically create getters and setters
// for a particulary property on an object
const lensProp = prop => ({
  view: store => store[prop],
  set: (value, store) => ({
    ...store,
    [prop]: value
  })
})
```

Now with our functions, we can create lenses for particular props of an object, and `view` and `set` those propertys immutably as pure functions.

```javascript
const author = {
  name: 'Kyle Shevlin',
  age: 34
}

const nameLens = lensProp('name')
const ageLens = lensProp('age')

console.log(view(nameLens, author)) // 'Kyle Shevlin'
console.log(set(ageLens, 35, author)) // { name: 'Kyle Shevlin', age: 35}
```

As is, this might not seem very impressive, but let's add a feature that will unlock just how powerful lenses are: composability.

### Adding Ramda to the Mix

I want you to completely forget about my naive implementation of `view`, `set`, and even `lensProp` right now. They were just to whet your tongue, a lens appetizer, if you will. We need something more substantial, though, something that'll do for a real main course.

The [Ramda](https://ramdajs.com) library is a powerful utility library made for functional programming. It's worth checking out more fully on your own time, but right now, we're going to use a few of its methods that are specifically designed for lenses. **From this point forward, we are using methods from the Ramda library to unlock the power of lenses**.

Ramda provides a `view`, `set`, and `lensProp` function similar to what I built before, but these are composable, meaning that I can combine `lensProp`s to be able to get and set data that is deeply nested in a structure. Let's imagine that our `author` object from before got a little more complex.

```javascript
const author = {
  name: {
    first: 'Kyle',
    last: 'Shevlin'
  },
  age: 34,
  location: {
    city: 'Portland',
    state: 'OR',
    country: 'USA'
  },
  hobbies: [
    'Golf',
    'Ultimate Frisbee',
    'Video Games',
    'Woodworking',
    'Making Music'
  ]
}
```

Alright, we've added a view nested objects and an array. Let's see what Ramda can do for us:

```javascript
import { compose, lensIndex, lensProp, set, view } from 'ramda'

// I like alphabetizing things when the order doesn't matter for faster scannability
const firstLens = lensProp('first')
const headLens = lensIndex(0)
const hobbiesLens = lensProp('hobbies')
const locationLens = lensProp('location')
const nameLens = lensProp('name')
const stateLens = lensProps('state')

// That's enough lenses to get started. Let's compose some for the nested objects
const firstNameLens = compose(
  nameLens,
  firstLens
)
const hobbiesHeadLens = compose(
  hobbiesLens,
  headLens
)
const locationStateLens = compose(
  locationLens,
  stateLens
)

// Now we can use these combined lenses to get and set our data
console.log(view(firstNameLens, author)) // 'Kyle'
console.log(view(hobbiesHeadLens, author)) // 'Golf'
console.log(set(stateLens, 'ME', author))
// {
//   name: {
//     first: 'Kyle',
//     last: 'Shevlin'
//   },
//   age: 34,
//   location: {
//     city: 'Portland',
//     state: 'ME',
//     country: 'USA'
//   },
//   hobbies: ['Golf', 'Ultimate Frisbee', 'Video Games', 'Woodworking', 'Making Music']
// }
```

Don't worry, I'm not moving to Maine (though I bet fall looks gorgeous there right now). But look how easy it is to create a function that can get deeply nested data. This is powerful because if I use lenses to get and set my data, then when the data structure changes, I only have to update what the lens focuses on, not all the locations I'm calling that data. If instead of nesting the first name in `name.first`, we changed it to `firstName`, I only have to update the `firstNameLens` to `lensProp('firstName')` instead of its current composition and the lens still works through out my application.
