---
date: '2021-02-23'
slug: 'how-to-use-react-context-effectively'
title: 'How to Use React Context Effectively'
subtitle: null
description: ''
excerpt: null
tags: ['React']
relatedPostsSlugs: []
---

In this post, I want to go over how I use React Context.

### Always export your own `Provider`

I cannot remember a single time in my years of writing React where there was a good reason for me _not_ to create a custom `Provider` for a context. I do this like so:

```jsx
const MyContext = React.createContext()

export function MyProvider({ children }) {
  return <MyContext.Provider value={null}>{children}</MyContext.Provider>
}
```

Why do I do this? I do this so that I have full control over `value`. I do not want to give users of my `Provider` options that I do not explicitly control. I can give them props that will allow them to alter whatever `value` is eventually set to, but I am still in control. This prevents a number of future problems and encapsulates the concerns of the Context well.

### Create a custom hook for your context

There was a short window of time where we needed to use the `Context.Consumer` render prop pattern, but I haven't used it since React Hooks made consuming context significantly easier.

Rather than pass my Context object around and passing it into `React.useContext` in ever component I need it, I instead export a custom hook from the same file I create the Context, like so:

```javascript
export const useMyContext = () => React.useContext(MyContext)
```

Now, any component that needs this Context can import `useMyContext` and use it.

### Optimize components that consume your custom hook

From the React docs:

> All consumers that are descendants of a Provider will re-render whenever the Providerâ€™s `value` prop changes.

Remember that quote. All Consumers rerender when the Provider updates, _regardless of whether it is necessary or not_. This means, if you're not careful, you could be causing a lot of unnecessary rerenders in your application. We are responsible for preventing unnecessary rerenders, so how do we do this for components that consume a context?

There are primarily two ways to accomplish. Both use memoization but in different ways.

The first way is to turn the component that consumes the context into a "container component" and to use `React.memo` on the "presentational component" that the container returns. Like so:

```jsx
import React from 'react'
import { useAuthContext } from './AuthContext'

export function HeaderContainer({ children }) {
  const [authState, { logIn, logOut }] = useAuthContext()

  return <Header authState={authState} logIn={logIn} logOut={logOut} />
}

const Header = React.memo(function Header({ authState, logIn, logOut }) {
  return (
    <header>
      <nav />
      {authState === 'loggedIn' && <LogoutButton onClick={logOut} />}
      {authState === 'loggedOut' && <LoginButton onClick={logIn} />}
    </header>
  )
})
```

This works because we turn the `value` of the context into props passed to a memoized component. The memoized component only updates if the props change.

The second technique does not require an extra component, but instead uses `React.useMemo` to memoize what we return from the component that consumes the context. Like so:

```jsx
import React from 'react'
import { useAuthContext } from './AuthContext'

function Header({ authState, logIn, logOut }) {
  const [authState, { logIn, logOut }] = useAuthContext()

  return React.useMemo(
    () => (
      <header>
        <nav />
        {authState === 'loggedIn' && <LogoutButton onClick={logOut} />}
        {authState === 'loggedOut' && <LoginButton onClick={logIn} />}
      </header>
    ),
    [authState, logIn, logOut]
  )
}
```

This strategy works by memoizing the return value of our component, only recalculating it when one of our `auth` related values changes.
