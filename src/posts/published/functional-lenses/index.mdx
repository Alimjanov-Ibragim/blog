---
date: '2019-10-12'
slug: 'functional-lenses'
title: 'Functional Lenses'
---

import { FootnoteMarker as Marker } from '../../../components/Footnotes'

The other day I was making changes to a part of Webflow's codebase that heavily depends on _lenses_. If you've never heard about them, have no fear. I had no idea what they were either. But after some research, I quickly realized just how useful they can be, why we use them at Webflow, and why I might use them in my own projects going forward. Let me teach you what I've learned.

### What is a `lens`?

A lens is a composable pair of pure functions, a "getter" and "setter", focused on a particular part of a greater data structure. <Marker index={1} content="Typically this data structure is an object, but it can be used on some other data structures as well" /> The lens is used to `view` and `set` the focused part, such as a key on an object (even a particular deeply nested key).

The "getter" of a lens receives the whole data structure and returns just the part on which it is focused.

```javascript
const getter = whole => part
```

The setter of a lens receives the whole data structure, the value we would like to set at the part on which we are focused, and returns a brand new data structure with the updated data (this is an immutable update, to learn more about immutability, you can read my blog post on it [here](/just-enough-fp-immutability)).

```javascript
const setter = whole => update => newWholeWithUpdateApplied
```

Now, if we were to take these concepts and write some real code that accomplished this from scratch, it might look something like this:

```javascript
// Generic `view` and `set` functions that can be used on any lens
const view = (lens, store) => lens.view(store)
const set = (lens, value, store) => lens.set(value, store)

// A lens factory that is designed to specifically create getters and setters
// for a particulary property on an object
const lensProp = prop => ({
  view: store => store[prop],
  set: (value, store) => ({
    ...store,
    [prop]: value
  })
})
```

Now with our functions, we can create lenses for particular props of an object, and `view` and `set` those properties immutably as pure functions.

```javascript
const author = {
  name: 'Kyle Shevlin',
  age: 34
}

const nameLens = lensProp('name')
const ageLens = lensProp('age')

console.log(view(nameLens, author)) // 'Kyle Shevlin'
console.log(set(ageLens, 35, author)) // { name: 'Kyle Shevlin', age: 35}
```

As is, this might not seem very impressive, but let's add a feature that will unlock just how powerful lenses are: composability.

### Adding Ramda to the Mix

I want you to completely forget about our naive implementation of `view`, `set`, and even `lensProp` right now. They were just to whet your tongue, a lens appetizer, if you will. We need something more substantial, though, for the real main course.

The [Ramda](https://ramdajs.com) library is a powerful utility library made for functional programming. It's worth checking out more fully on your own time, but right now, we're going to use a few of its methods that are specifically designed for lenses. **From this point forward, we are using methods from the Ramda library to unlock the power of lenses**.

Ramda provides a `view`, `set`, and `lensProp` function similar to what we built before, but these are composable. That means we can combine `lensProp`s to be able to get and set data that is deeply nested in a structure. Let's imagine that our `author` object from before became a little more complex.

```javascript
const author = {
  name: {
    first: 'Kyle',
    last: 'Shevlin'
  },
  age: 34,
  location: {
    city: 'Portland',
    state: 'OR',
    country: 'USA'
  },
  hobbies: [
    'Golf',
    'Ultimate Frisbee',
    'Video Games',
    'Woodworking',
    'Making Music'
  ]
}
```

Alright, we've added a view nested objects and an array. Let's see what Ramda can do for us:

```javascript
import { compose, lensIndex, lensProp, set, view } from 'ramda'

// I like alphabetizing things when the order doesn't matter for faster scannability
const firstLens = lensProp('first')
const headLens = lensIndex(0)
const hobbiesLens = lensProp('hobbies')
const locationLens = lensProp('location')
const nameLens = lensProp('name')
const stateLens = lensProps('state')

// That's enough lenses to get started. Let's compose some for the nested objects
const firstnameLens = compose(
  nameLens,
  firstLens
)
const firstHobbyLens = compose(
  hobbiesLens,
  headLens
)
const locationStateLens = compose(
  locationLens,
  stateLens
)

// Now we can use these composed lenses to get and set our data
console.log(view(firstnameLens, author)) // 'Kyle'
console.log(view(firstHobbyLens, author)) // 'Golf'
console.log(set(locationStateLens, 'ME', author))
// {
//   name: {
//     first: 'Kyle',
//     last: 'Shevlin'
//   },
//   age: 34,
//   location: {
//     city: 'Portland',
//     state: 'ME',
//     country: 'USA'
//   },
//   hobbies: ['Golf', 'Ultimate Frisbee', 'Video Games', 'Woodworking', 'Making Music']
// }
```

Don't worry, I'm not moving to Maine. <Marker index={2} content="Though I would love to visit in the fall sometime" /> But look how easy it is to create a function that can get and set deeply nested data. This is powerful because if I use lenses to get and set my data, then when the data structure changes, I only have to update what the lens focuses on, not all the locations I'm calling that data. If instead of nesting the first name in `name.first`, we changed it to `firstName`, I only have to update the `firstnameLens` composition. <Marker index={3} content="It won't actually be a composition if that change is made, but roll with me" /> This is all we do:

```javascript
const firstnameLens = lensProp('firstName')
```

And now every use of `firstnameLens` in my application is updated to the newly structured data. In this way, we can decouple how we handle our data from the actual structure itself.

Imagine using this with something like Redux stores? Or perhaps you have a central store of data somehow in your application. You can create a function designed to be focused on a part of the store and pass that around.

```javascript
// settingsStore.js
export const darkModeLens = compose()
// ...all the lenses needed for the dark mode setting

// someOtherFile.js
import { darkModeLens } from './settingsStore'

//...further down that file
function DarkModeToggle = () => (
  <button onClick={() => { set(darkModeLens, !view(darkModeLens)) }}>
    Toggle Dark Mode
  </button>
)
```
