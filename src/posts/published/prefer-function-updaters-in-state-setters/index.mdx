---
date: '2021-08-25'
slug: 'prefer-function-updaters-in-state-setters'
title: 'Prefer Function Updaters In State Setters'
subtitle: null
description: ''
excerpt: null
tags: ['React']
relatedPostsSlugs: []
---

import ItemSelectorBad from './ItemSelectorBad'

This one will be short and sweet. You're using React. You have some state.

```javascript
const [selectedItem, setSelectedItem] = React.useState(null)
```

You're already on board with the concepts in [useEncapsulation](/use-encapsulation) and [Prefer Declarative State Updaters](/prefer-declarative-state-updaters), so you make a custom hook combining your state with the functions that will update that state.

```javascript
function useItemSelection() {
  const [selectedItem, setSelectedItem] = React.useState(null)

  const handlers = React.useMemo(
    () => ({
      selectItem: item => {
        setSelectedItem(item)
      },
      unselectItem: () => {
        setSelectedItem(null)
      },
    }),
    []
  )

  return [selectedItem, handlers]
}
```

Fantastic. Your selection logic is encapsulated in a nice, little custom hook. Your boss and colleagues love you and your code. All is well in the world!

Until...

You get some new requirements.

"We would love it if clicking on the **currently selected item** would **unselect** the item, rather than do nothing. Can you do that?"

Of course we can! But the question is how shall we do it? There are at minimum, two ways. Let's do it the wrong way first.

In order to "unselect" an item, we need to know that the item we're selecting is the same as current `selectedItem`. We could use the `selectedItem` that's in scope.

```javascript
function useItemSelection() {
  const [selectedItem, setSelectedItem] = React.useState(null)

  const handlers = React.useMemo(
    () => ({
      // ...same handlers as before

      smartSelectItem: item => {
        // Here we use `selectedItem` from the parent scope
        // We're _also_ assuming the "items" have an `id`
        // We will fix that later
        if (item?.id === selectedItem?.id) {
          setSelectedItem(null)
          return
        }

        setSelectedItem(item)
      },
    }),
    // Now we had to add `selectedItem` as a dependency
    // All handlers will update _every_ time `selectedItem` updates
    [selectedItem]
  )

  return [selectedItem, handlers]
}
```

We can pop this into a component and see that it works.

<OffsetWrap>
  <ItemSelectorBad />
</OffsetWrap>
